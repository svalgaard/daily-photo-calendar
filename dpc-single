#! /usr/bin/env python3
# -*- encoding: utf-8 -*-
#
#

import argparse
import libdpc
import libpic
import libarg
import libbox
import re
import sys
import PIL.ImageColor


def addPicture(image, args, goTOP=None):
    TOP = args.format[0] == 't' if goTOP is None else goTOP
    libdpc.debug('addPicture', 'At top?', TOP)

    # handle portrait images
    if not args.image.isLandscape():
        if TOP:
            libdpc.debug('addPicture', 'portrait image: rotating CW')
            args.image = args.image.rotateCW()
            image = addPicture(image.rotateCW(), args).rotateCCW()
            args.image = args.image.rotateCCW()
        else:
            libdpc.debug('addPicture', 'portrait image: rotating CCW')
            args.image = args.image.rotateCCW()
            image = addPicture(image.rotateCCW(), args, True).rotateCW()
            args.image = args.image.rotateCW()
        return image

    # margin in pixels
    mpO = args.size[1] * args.marginOuter / 100
    mpI = args.size[1] * args.marginInner / 100
    libdpc.debug('handle', 'Margins in pixels:', mpO, mpI)

    x, y, w, h = 0, 0, image.size[0], image.size[1]
    h = int(image.size[0] / args.ratio)
    if not TOP:
        y = image.size[1] - h

    pimg = libpic.cropImage(args.image, (w, h), False)
    image.paste(pimg, (x, y))
    libdpc.debug('handle', (x, y, w, h), 'Input image pasted')

    if args.text:
        # we are always slightly above or below the image
        th = args.textFont.dsize
        if not th or th <= 0:
            th = int(mpI)
        if TOP:
            box = libpic.intBox((mpO, h, w-mpO, h + th))  # text below image
        else:
            box = libpic.intBox((mpO, y - th, w-mpO, y))
        font = libpic.scaleFont(args.textFont, 2*th//3)

        libpic.textDraw(image, box,
                        args.text, args.textColor,
                        font, position=(-1, libpic.CENTER))
        libdpc.debug('handle', box, 'Text', repr(args.text))

    # determine location of remaining space
    a, b, c, d = mpO, mpO, image.size[0] - mpO, image.size[1] - mpO
    if TOP:
        # at the bottom
        b = h + mpI
    else:
        d = y - mpI

    image.box = libpic.intBox((a, b, c, d))
    return image


def findContentBoxes(image, args):
    libdpc.debug('handle', image.box, 'Content-area')
    fmts = args.format[1]

    mpI = args.size[1] * args.marginInner / 100

    boxes, boxCount = [], len(fmts)
    w, h = image.box[2]-image.box[0], image.box[3]-image.box[1]
    for i in range(boxCount):
        a, b, c, d = image.box
        if w > h:
            # landscape
            boxw = (w - mpI*(boxCount-1)) / boxCount
            a += (boxw + mpI) * i
            c = a + boxw
        else:
            boxh = (h - mpI*(boxCount-1)) / boxCount
            b += (boxh + mpI) * i
            d = b + boxh
        boxes.append((fmts[i], libpic.intBox((a, b, c, d))))
    return boxes


def handle(args):
    global image

    libdpc.debug('handle', 'Format used', args.format)

    image = libpic.decorateImage(PIL.Image.new('RGB', args.size, args.bgcolor))
    image = addPicture(image, args)

    boxes = findContentBoxes(image, args)
    for i, (f, box) in enumerate(boxes):
        fn = libbox.getFuncForBoxType(f)
        libdpc.debug('handle', box, 'Subbox', i, 'format', f)
        fn(args, f, image, box)
    image.show()


def mmarg(arg, **args):
    assert(arg.type)
    arg.type = libarg.maybeMore(arg.type, **args)
    arg.mm = True
    return arg


def main():
    desc = '''Create a single calendar page.

In all cases where it makes sense, unless otherwise noted all options
can be supplied with two suboptions for landscape resp. portrait images,
e.g., --margin-inner 4:5 (meaning 4% for landscape pictures and 5% for
portrait pictures).'''
    parser = argparse.ArgumentParser(description=desc)

    parser.add_argument('-v', '--verbose', dest='verbose', default=False,
                        help='Be more verbose',
                        action='store_true')

    pgen = parser.add_argument_group('General setup')
    mmarg(pgen.add_argument('-s', '--size', dest='size', default='1200x1050',
                            help='size of a page in pixels '
                            '(default %(default)s)',
                            metavar='SIZE',
                            type=libarg.REType('WIDTHxHEIGHT', r'\d+x\d+')))
    mmarg(pgen.add_argument('--margin-outer', dest='marginOuter',
                            default='4.5', metavar='RATIO',
                            help='outer margin in %% (default %(default)s)',
                            type=libarg.RangeCheck(float, 0, 40)))
    mmarg(pgen.add_argument('--margin-inner', dest='marginInner',
                            metavar='RATIO', default='2.25',
                            help='inner margin in %% (default %(default)s)',
                            type=libarg.RangeCheck(float, 0, 20)))
    reformat = r'([tb])((?:%s)+)' % '|'.join(libbox.getBoxTypes())
    mmarg(pgen.add_argument('-f', '--format', dest='format',
                            default='tmdc',
                            help='format of each page (default %(default)s)',
                            metavar='FORMAT',
                            type=libarg.REType(reformat, reformat)))
    mmarg(pgen.add_argument('--bgcolor', dest='bgcolor', default='#DEDEDE',
                            help='background color (default %(default)s)',
                            metavar='COLOR',
                            type=PIL.ImageColor.getrgb))

    ppic = parser.add_argument_group('Picture')
    ppic.add_argument('-p', '--picture', dest='imagefd', default=None,
                      help='filename of picture to use',
                      metavar='FILENAME', required=True,
                      type=argparse.FileType('rb'))
    mmarg(ppic.add_argument('-r', '--ratio', dest='ratio',
                            default='1.5:1.3333333',
                            help='ratio to crop all images to '
                            '(default %(default)s)',
                            metavar='RATIO',
                            type=libarg.RangeCheck(float, 0, 10)))
    ppic.add_argument('--text', dest='text', default='',
                      help='text to show below image (default none)',
                      metavar='TEXT',
                      type=str)
    mmarg(ppic.add_argument('--text-font', dest='textFont',
                            default='Raleway-Regular',
                            help='font for text to show below image '
                            '(default %(default)s)',
                            metavar='FONT',
                            type=libarg.Font))
    mmarg(ppic.add_argument('--text-color', dest='textColor',
                            default='#000000',
                            help='color for text to show below image '
                            '(default %(default)s)',
                            metavar='COLOR',
                            type=PIL.ImageColor.getrgb))

    args = parser.parse_args()

    try:
        # The file has already been opened
        args.image = libpic.decorateImage(PIL.Image.open(args.imagefd))
    except IOError:
        libdpc.error('main', '%r does not contain valid image data' %
                     args.imagefd.name)
        sys.exit(1)

    # use options depending on whether it's a landscape or portrait image
    libarg.deMore(args, 0 if args.image.isLandscape() else 1)

    # Now check some of options
    libdpc.VERBOSE = 2 if args.verbose else 1

    args.size = tuple(map(int, args.size.split('x')))

    formatsp = r'(%s)' % '|'.join(libbox.getBoxTypes())
    formatsp = tuple(filter(None, re.split(formatsp, args.format[1])))
    args.format = args.format[0], formatsp

    handle(args)


if __name__ == '__main__':
    main()
